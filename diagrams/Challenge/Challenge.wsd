@startuml Challenge
interface Models.Challenge {
    sid: String
    challengeDetails: ChallengeDetails
    hiddenDetails: String
    factorSid: String
    status: ChallengeStatus
    createdDate: Date
    updatedDate: Date
    expirationDate: Date
}
interface Models.ChallengeDetails {
    message: String
    custom: List<Detail>
    date: Date
}
interface Models.ChallengeDetails.Detail {
    label: String
    value: String
}
class Domain.Models.FactorChallenge implements Models.Challenge  {
    factor: Factor
    details: String
}
enum Models.ChallengeStatus {
    Pending
    Approved
    Denied
    Expired
}
class Domain.Challenge.ChallengeMapper {
    fromApi(jsonObject: JSONObject): Challenge
}
class API.ChallengeAPIClient {
    get(sid: String, factor: Factor, success: (JSONObject)->(), error: (TwilioVerifyException)->())
    update(challenge: Challenge, authPayload: String, success: ()->(), error: (TwilioVerifyException)->())
}
interface Domain.Challenge.ChallengeProvider {
    get(sid: String, factor: Factor, success: (Challenge)->(), error: (TwilioVerifyException)->())
    update(challenge: Challenge, authPayload: String, success: (Challenge)->(), error: (TwilioVerifyException)->())
}
class Domain.Challenge.ChallengeRepository implements Domain.Challenge.ChallengeProvider {

}
class Domain.Challenge.PushChallengeProcessor {
    get(sid: String, factor: PushFactor, success: (Challenge)->(), error: (TwilioVerifyException)->())
    update(sid: String, factor: PushFactor, status: ChallengeStatus, success: ()->(), error: (TwilioVerifyException)->())
}
Domain.Challenge.ChallengeRepository o--> Domain.Challenge.ChallengeMapper: map response
Domain.Challenge.ChallengeRepository o--> API.ChallengeAPIClient: get/update challenge
Domain.Challenge.PushChallengeProcessor o--> Domain.Challenge.ChallengeRepository: get/update challenge
Domain.Challenge.PushChallengeProcessor o--> Data.KeyStorage: calculate signature
@enduml